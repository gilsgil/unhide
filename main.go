package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"sync"
)

// Color codes for terminal output
const (
	green  = "\033[32m"
	purple = "\033[35m"
	reset  = "\033[0m"
)

// ArjunParams represents the JSON structure generated by Arjun.
type ArjunParams struct {
	Params []string `json:"params"`
}

// runArjun executes Arjun with specified arguments.
func runArjun(
	url, outputPath, wordlistPath string,
	headers string,
	passive bool,
	stable bool,
	method string,
	chunkSize string,
) bool {
	// Build base arguments
	args := []string{
		"-u", url,
		"-o", outputPath,
	}

	// If a method is provided, add it (e.g. GET, POST, etc.). Default is "GET"
	if method != "" {
		args = append(args, "-m", method)
	}

	// If using a custom chunk size, add it. Otherwise, Arjun uses its default.
	if chunkSize != "" {
		args = append(args, "-c", chunkSize)
	}

	// If a wordlist path is provided, add it
	if wordlistPath != "" {
		args = append(args, "-w", wordlistPath)
	}

	// Additional optional Arjun flags
	if headers != "" {
		// Multiple headers can be separated by \n
		args = append(args, "--headers", headers)
	}
	if passive {
		args = append(args, "--passive")
	}
	if stable {
		args = append(args, "--stable")
	}

	cmd := exec.Command("arjun", args...)
	if _, err := cmd.CombinedOutput(); err != nil {
		return false
	}
	return true
}

// loadParamsFromJSON loads Arjun's JSON output into a map[URL]ArjunParams.
func loadParamsFromJSON(outputPath string) (map[string]ArjunParams, error) {
	info, err := os.Stat(outputPath)
	if err != nil {
		return nil, err
	}
	if info.Size() == 0 {
		return nil, fmt.Errorf("empty JSON file")
	}

	bytes, err := ioutil.ReadFile(outputPath)
	if err != nil {
		return nil, err
	}

	var data map[string]ArjunParams
	if err := json.Unmarshal(bytes, &data); err != nil {
		return nil, err
	}
	return data, nil
}

// getOriginalQueryParams extracts the parameter names from the original URL (before Arjun).
func getOriginalQueryParams(fullURL string) map[string]bool {
	existing := make(map[string]bool)

	parsed, err := url.Parse(fullURL)
	if err != nil {
		// If we can't parse, just return empty
		return existing
	}
	q := parsed.Query()
	for k := range q {
		existing[k] = true
	}
	return existing
}

// processURL runs Arjun on a single URL, excludes parameters that already
// exist in the original query, and prints only newly discovered parameters.
func processURL(
	originalURL, wordlistPath string,
	headers string,
	passive, stable bool,
	method, chunkSize string,
	showOnlyNewParams bool,
) {
	// Temporary file for Arjun's JSON output
	tmpFile, err := ioutil.TempFile("", "*.json")
	if err != nil {
		return
	}
	tmpFilePath := tmpFile.Name()
	tmpFile.Close()
	defer os.Remove(tmpFilePath)

	// Execute Arjun
	if !runArjun(originalURL, tmpFilePath, wordlistPath, headers, passive, stable, method, chunkSize) {
		return
	}

	// Parse the JSON
	paramsData, err := loadParamsFromJSON(tmpFilePath)
	if err != nil {
		return
	}

	// For each URL in the JSON, we only print newly discovered params
	for foundURL, arjunParams := range paramsData {
		// 1) Grab the existing parameters from the original (or found) URL
		//    If you want to use `originalURL`'s query strictly, do so:
		existingParamMap := getOriginalQueryParams(originalURL)

		// 2) Filter out any param that's already in `existingParamMap`
		var newParams []string
		for _, p := range arjunParams.Params {
			if !existingParamMap[p] {
				newParams = append(newParams, p)
			}
		}

		// If no new parameters, skip printing altogether
		if len(newParams) == 0 {
			continue
		}

		if showOnlyNewParams {
			// "showOnlyNewParams" means we want:
			//   https://example.com/app?callback=FUZZ
			// ...with ONLY newly discovered param(s)

			// parse foundURL so we can reconstruct it w/o the old query
			parsed, err := url.Parse(foundURL)
			if err != nil {
				// If parse fails, just skip
				continue
			}
			// Clear out any existing query
			parsed.RawQuery = ""

			// Build "param1=FUZZ&param2=FUZZ"
			q := url.Values{}
			for _, p := range newParams {
				q.Set(p, "FUZZ")
			}
			parsed.RawQuery = q.Encode()

			fmt.Println(parsed.String())

		} else {
			// If not in "showOnlyNewParams" mode,
			// we print the original URL plus the discovered param info.
			// E.g. "https://example.com/app?search=test --> Found: callback"
			//
			// We'll color "Found:" in green, discovered param(s) in purple.

			// Build a string of discovered param(s), e.g. "callback, foo"
			coloredParams := purple + strings.Join(newParams, ", ") + reset
			coloredFound := green + "Found:" + reset

			fmt.Printf("%s --> %s %s\n", originalURL, coloredFound, coloredParams)
		}
	}
}

// processURLs handles parallel processing of multiple URLs
func processURLs(
	urls []string, threads int, wordlistPath string,
	headers string,
	passive, stable bool,
	method, chunkSize string,
	showOnlyNewParams bool,
) {
	var wg sync.WaitGroup
	ch := make(chan string)

	// Spawn worker goroutines
	for i := 0; i < threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for urlItem := range ch {
				processURL(urlItem, wordlistPath, headers, passive, stable, method, chunkSize, showOnlyNewParams)
			}
		}()
	}

	// Send URLs down the channel
	for _, u := range urls {
		ch <- u
	}
	close(ch)

	// Wait for completion
	wg.Wait()
}

// readURLsFromStdin reads URLs from stdin (piped data)
func readURLsFromStdin() []string {
	var urls []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			urls = append(urls, line)
		}
	}
	return urls
}

// readURLsFromFile reads URLs (one per line) from a file
func readURLsFromFile(filepath string) ([]string, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var urls []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			urls = append(urls, line)
		}
	}
	return urls, nil
}

// createTempWordlistFromParams builds a temporary file from comma-separated parameters
func createTempWordlistFromParams(params string) (string, error) {
	// Split by comma
	paramList := strings.Split(params, ",")

	// Clean up whitespace
	cleanList := make([]string, 0, len(paramList))
	for _, p := range paramList {
		p = strings.TrimSpace(p)
		if p != "" {
			cleanList = append(cleanList, p)
		}
	}

	// (Optional) if you want extra placeholders, add them:
	// extraParams := []string{"param1", "param2", "param3"}
	// cleanList = append(cleanList, extraParams...)

	// Create temp file
	tmpFile, err := ioutil.TempFile("", "arjunParams-*.txt")
	if err != nil {
		return "", err
	}
	defer tmpFile.Close()

	// Write each parameter to its own line
	for _, p := range cleanList {
		_, writeErr := tmpFile.WriteString(p + "\n")
		if writeErr != nil {
			return "", writeErr
		}
	}

	return tmpFile.Name(), nil
}

func main() {
	// Basic flags
	urlFlag := flag.String("u", "", "Single URL to test")
	listFlag := flag.String("l", "", "File containing URLs (one per line)")
	threadsFlag := flag.Int("t", 5, "Number of threads for parallel processing")

	// Wordlist flags
	wordlistFlag := flag.String("w", "", "Custom wordlist file path to pass to Arjun")
	paramsFlag := flag.String("p", "", "Comma-separated parameters to create a temporary wordlist")

	// Additional Arjun flags
	headersFlag := flag.String("headers", "", "Additional headers (separate multiple with '\\n')")
	passiveFlag := flag.Bool("passive", false, "Enable passive parameter collection")
	stableFlag := flag.Bool("stable", false, "Prefer stability over speed")

	// Method flag
	methodFlag := flag.String("m", "GET", "Request method to use: GET/POST/XML/JSON (default: GET)")

	// New flag: show only newly discovered params in final output
	showOnlyNewParamsFlag := flag.Bool("show", false, "Only print newly discovered params. Otherwise, print 'URL --> Found: param'")

	flag.Parse()

	// Gather URLs
	var urls []string
	if *urlFlag != "" {
		urls = append(urls, *urlFlag)
	} else if *listFlag != "" {
		listURLs, err := readURLsFromFile(*listFlag)
		if err != nil {
			fmt.Printf("Error opening file: %v\n", err)
			os.Exit(1)
		}
		urls = listURLs
	} else {
		// Check if data is being piped via stdin
		stat, _ := os.Stdin.Stat()
		if stat.Mode()&os.ModeNamedPipe != 0 {
			urls = readURLsFromStdin()
		}
	}

	// Determine final wordlist to use
	// Priority: -p (temp file) > -w (file) > none (use Arjun default)
	var finalWordlistPath string
	var cleanupWordlist bool
	var chunkSize string // empty = let Arjun use its default

	if *paramsFlag != "" {
		p, err := createTempWordlistFromParams(*paramsFlag)
		if err != nil {
			fmt.Printf("Error creating temporary wordlist: %v\n", err)
			os.Exit(1)
		}
		finalWordlistPath = p
		cleanupWordlist = true
		// If using a small param-based wordlist, let's set chunkSize=1
		chunkSize = "1"
	} else if *wordlistFlag != "" {
		finalWordlistPath = *wordlistFlag
		// chunkSize remains empty -> uses Arjun default
	}

	// Process the URLs
	if len(urls) > 0 {
		processURLs(
			urls,
			*threadsFlag,
			finalWordlistPath,
			*headersFlag,
			*passiveFlag,
			*stableFlag,
			*methodFlag,
			chunkSize,
			*showOnlyNewParamsFlag,
		)
	} else {
		fmt.Println("No URLs provided. Use -u for a single URL, -l for a list of URLs, or pass URLs via stdin.")
	}

	// Clean up temp wordlist if created
	if cleanupWordlist {
		os.Remove(finalWordlistPath)
	}
}
