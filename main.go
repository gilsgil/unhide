package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"sync"
)

// ArjunParams represents the JSON structure generated by Arjun.
type ArjunParams struct {
	Params []string `json:"params"`
}

// runArjun executes Arjun with specified arguments, returning true if the command
// succeeds (exit code 0), otherwise false.
func runArjun(
	url, outputPath, wordlistPath string,
	headers string,
	passive bool,
	stable bool,
	method string,
	chunkSize string,
) bool {
	// Build base arguments
	args := []string{
		"-u", url,
		"-o", outputPath,
	}

	// If a method is provided, add it (e.g. GET, POST, etc.). Default is "GET"
	if method != "" {
		args = append(args, "-m", method)
	}

	// If using a custom chunk size, add it. Otherwise, Arjun uses its default.
	if chunkSize != "" {
		args = append(args, "-c", chunkSize)
	}

	// If a wordlist path is provided, add it
	if wordlistPath != "" {
		args = append(args, "-w", wordlistPath)
	}

	// Additional optional Arjun flags
	if headers != "" {
		// Multiple headers can be separated by \n
		args = append(args, "--headers", headers)
	}
	if passive {
		args = append(args, "--passive")
	}
	if stable {
		args = append(args, "--stable")
	}

	cmd := exec.Command("arjun", args...)
	// We discard Arjun's actual output, only capturing success/failure
	if _, err := cmd.CombinedOutput(); err != nil {
		return false
	}
	return true
}

// loadParamsFromJSON loads Arjun's JSON output into a map[URL]ArjunParams.
func loadParamsFromJSON(outputPath string) (map[string]ArjunParams, error) {
	info, err := os.Stat(outputPath)
	if err != nil {
		return nil, err
	}
	if info.Size() == 0 {
		return nil, fmt.Errorf("empty JSON file")
	}

	bytes, err := ioutil.ReadFile(outputPath)
	if err != nil {
		return nil, err
	}

	var data map[string]ArjunParams
	if err := json.Unmarshal(bytes, &data); err != nil {
		return nil, err
	}
	return data, nil
}

// processURL runs Arjun on a single URL, then prints discovered parameters as "?param=FUZZ&param2=FUZZ"
func processURL(
	url, wordlistPath string,
	headers string,
	passive, stable bool,
	method string,
	chunkSize string,
) {
	// Temporary file to hold Arjun's JSON output
	tmpFile, err := ioutil.TempFile("", "*.json")
	if err != nil {
		return
	}
	tmpFilePath := tmpFile.Name()
	tmpFile.Close()
	defer os.Remove(tmpFilePath)

	// Execute Arjun
	if !runArjun(url, tmpFilePath, wordlistPath, headers, passive, stable, method, chunkSize) {
		return
	}

	// Parse the JSON
	paramsData, err := loadParamsFromJSON(tmpFilePath)
	if err != nil {
		return
	}

	// Print discovered parameters
	for foundURL, arjunParams := range paramsData {
		if len(arjunParams.Params) > 0 {
			var pairs []string
			for _, p := range arjunParams.Params {
				pairs = append(pairs, fmt.Sprintf("%s=FUZZ", p))
			}
			queryString := strings.Join(pairs, "&")
			fmt.Println(foundURL + "?" + queryString)
		}
	}
}

// processURLs handles parallel processing of multiple URLs
func processURLs(
	urls []string, threads int, wordlistPath string,
	headers string,
	passive, stable bool,
	method string,
	chunkSize string,
) {
	var wg sync.WaitGroup
	ch := make(chan string)

	// Spawn worker goroutines
	for i := 0; i < threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for url := range ch {
				processURL(url, wordlistPath, headers, passive, stable, method, chunkSize)
			}
		}()
	}

	// Send URLs down the channel
	for _, u := range urls {
		ch <- u
	}
	close(ch)

	// Wait for completion
	wg.Wait()
}

// readURLsFromStdin reads URLs from stdin (piped data)
func readURLsFromStdin() []string {
	var urls []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			urls = append(urls, line)
		}
	}
	return urls
}

// readURLsFromFile reads URLs (one per line) from a file
func readURLsFromFile(filepath string) ([]string, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var urls []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			urls = append(urls, line)
		}
	}
	return urls, nil
}

// createTempWordlistFromParams builds a temporary file from comma-separated parameters
func createTempWordlistFromParams(params string) (string, error) {
	// Split by comma
	paramList := strings.Split(params, ",")

	// Clean up whitespace
	cleanList := make([]string, 0, len(paramList))
	for _, p := range paramList {
		p = strings.TrimSpace(p)
		if p != "" {
			cleanList = append(cleanList, p)
		}
	}

	// (Optional) if you want extra placeholders, add them:
	//    extraParams := []string{"param1", "param2", "param3"}
	//    cleanList = append(cleanList, extraParams...)

	// Create temp file
	tmpFile, err := ioutil.TempFile("", "arjunParams-*.txt")
	if err != nil {
		return "", err
	}
	defer tmpFile.Close()

	// Write each parameter to its own line
	for _, p := range cleanList {
		_, writeErr := tmpFile.WriteString(p + "\n")
		if writeErr != nil {
			return "", writeErr
		}
	}

	return tmpFile.Name(), nil
}

func main() {
	// Basic flags
	urlFlag := flag.String("u", "", "Single URL to test")
	listFlag := flag.String("l", "", "File containing URLs (one per line)")
	threadsFlag := flag.Int("t", 5, "Number of threads for parallel processing")

	// Wordlist flags
	wordlistFlag := flag.String("w", "", "Custom wordlist file path to pass to Arjun")
	paramsFlag := flag.String("p", "", "Comma-separated parameters to create a temporary wordlist")

	// Additional Arjun flags
	headersFlag := flag.String("headers", "", "Additional headers (separate multiple with '\\n')")
	passiveFlag := flag.Bool("passive", false, "Enable passive parameter collection")
	stableFlag := flag.Bool("stable", false, "Prefer stability over speed")

	// Method flag
	methodFlag := flag.String("m", "GET", "Request method to use: GET/POST/XML/JSON (default: GET)")

	flag.Parse()

	// Gather URLs
	var urls []string
	if *urlFlag != "" {
		urls = append(urls, *urlFlag)
	} else if *listFlag != "" {
		listURLs, err := readURLsFromFile(*listFlag)
		if err != nil {
			fmt.Printf("Error opening file: %v\n", err)
			os.Exit(1)
		}
		urls = listURLs
	} else {
		// Check if data is being piped via stdin
		stat, _ := os.Stdin.Stat()
		if stat.Mode()&os.ModeNamedPipe != 0 {
			urls = readURLsFromStdin()
		}
	}

	// Determine final wordlist to use
	// Priority: -p (temp file) > -w (file) > none (use Arjun default)
	var finalWordlistPath string
	var cleanupWordlist bool
	var chunkSize string // empty = let Arjun use its default

	if *paramsFlag != "" {
		p, err := createTempWordlistFromParams(*paramsFlag)
		if err != nil {
			fmt.Printf("Error creating temporary wordlist: %v\n", err)
			os.Exit(1)
		}
		finalWordlistPath = p
		cleanupWordlist = true

		// If using a small param-based wordlist, let's set chunkSize=1
		chunkSize = "1"
	} else if *wordlistFlag != "" {
		finalWordlistPath = *wordlistFlag
		// chunkSize remains empty -> uses Arjun default
	}

	// Process the URLs
	if len(urls) > 0 {
		processURLs(
			urls,
			*threadsFlag,
			finalWordlistPath,
			*headersFlag,
			*passiveFlag,
			*stableFlag,
			*methodFlag,
			chunkSize,
		)
	} else {
		fmt.Println("No URLs provided. Use -u for a single URL, -l for a list of URLs, or pass URLs via stdin.")
	}

	// Clean up temp wordlist if created
	if cleanupWordlist {
		os.Remove(finalWordlistPath)
	}
}
